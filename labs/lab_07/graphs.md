<!-- #region editable=true slideshow={"slide_type": ""} -->
## Лабораторная работа № 7  (Алгоритмы на графах)
***Выполнил***: Зейналли С.Р,  ***Группа***: ИУ10-36
<!-- #endregion -->

### **Цель работы** 

Изучение основных алгоритмов на графах

### **Алгоритмы обхода графов.**

Существует множество алгоритмов на графах, в основе которых лежит систематический перебор вершин графа, причем такой, что каждая вершина
просматривается (посещается) в точности один раз. 
Поэтому важной задачей является нахождение «хороших»  методов такого перебора.
Под обходом графа (поиском на графе) мы будем понимать процесс систематического просмотра всех вершин графа с целью отыскания вершин,
удовлетворяющих некоторому условию.

**Обход (поиск) в глубину**.

Идея алгоритма: из текущей вершины движемся в первую вершину, смежную с текущей, в которой мы еще не были, если таковая есть. 
Если таковой нет, то возвращаемся в вершину, из которой мы попали в текущую. 
Если же таковой нет, и мы оказались в исходной вершине (возвращаться некуда), то это означает, что перебор вершин графа закончен.
Номера просмотренных вершин графа запоминаются в стеке.

**Обход (поиск) в ширину**.

Идея алгоритма: метод поиска в ширину получается из алгоритма поиска в глубину, если мы заменим стек возврата на очередь. 
Эта простая замена модифицирует порядок обхода вершин так, что обход идет равномерно во все стороны, а не вглубь как при поиске в глубину.


##### **Алгоритмы поиска на графе.**

**Нахождение эйлерова цикла**.

Определение: Если граф имеет цикл (не обязательно простой), содержащий все ребра графа по одному разу, то такой цикл называется эйлеровым циклом.
Идея алгоритма: начиная с произвольной вершины, строим путь, удаляя ребра и запоминая вершины в стеке, до тех пор, пока множество смежности очередной вершины не окажется пустым, что означает, что путь удлинить нельзя. 
Заметим, что при этом мы с необходимостью придем в ту вершину, с которой начали. 
В противном случае это означало бы, что вершина $v$ имеет нечетную степень, что невозможно по условию. 
Таким образом, из графа были удалены ребра цикла, а вершины цикла были сохранены в стеке $S$. 
Заметим, что при этом степени всех вершин остались четными. 
Далее вершина $v$ выводится в качестве первой вершины эйлерова цикла, а процесс продолжается, начиная с вершины, стоящей на вершине
стека.

**Нахождение гамильтонова цикла**.

Определение: Граф называется гамильтоновым, если в нем имеется цикл, содержащий каждую вершину этого графа. 
Сам цикл также называется гамильтоновым.

Идея алгоритма: в основе лежит перебор с возвратом (backtracking).
Начинаем поиск решения, например, с первой вершины графа. 
Предположим, что уже найдены первые $k$ компонент решения. 
Рассматриваем ребра, выходящие из последней вершины. 
Если есть такие рёбра, что идут в ранее не просмотренные вершины, то включаем эту вершину в решение и помечаем ее как
просмотренную. 
Получена ($k+1$) компонента решения. 
Если такой вершины нет, то возвращаемся к предыдущей вершине и пытаемся найти ребро, выходящее из нее в другую вершину. 
Решение получено при просмотре всех вершин графа и возможности достичь из последней первой вершины. 
Решение (цикл) выводится и продолжается процесс нахождения следующих циклов.

##### **Алгоритм нахождения кратчайших путей в графе.**

**Алгоритм Дейкстры**.

Определение: Дан простой взвешенный граф $G(V,E)$ без петель и дуг отрицательного веса. 
Найти кратчайшие пути от некоторой вершины a графа $G$ до всех остальных вершин этого графа.

Идея алгоритма: метка самой вершины $u$ полагается равной 0, метки остальных вершин — бесконечности. 
Это отражает то, что расстояния от $u$ до других вершин пока неизвестны.
Все вершины графа помечаются как непосещенные. 
Если все вершины посещены, алгоритм завершается. 
В противном случае из еще не посещенных вершин выбирается вершина $u$, имеющая минимальную метку. 
Мы рассматриваем всевозможные маршруты, в которых $u$ является предпоследним пунктом. 
Вершины, соединенные с вершиной $u$ ребрами, назовем соседями этой вершины. 
Для каждого соседа рассмотрим новую длину пути, равную сумме текущей метки $u$ и длины ребра, соединяющего $u$ с этим соседом. 
Если полученная длина меньше метки соседа, заменим метку этой длиной.
Рассмотрев всех соседей, пометим вершину $u$ как посещенную и повторим шаг.


### Задание №**1.**
#### Реализовать программу, выполняющую описанный набор операций на графах:

Требования:
 - граф должен быть реализован в виде класса;
 - каждая операция должна быть реализована как метод класса.


```python
class Graph:
    def __init__(self):
        self.adj_list = {}

    def add_edge(self, u, v):
        # Добавляем ребра в граф (неориентированный)
        if u not in self.adj_list:
            self.adj_list[u] = []
        if v not in self.adj_list:
            self.adj_list[v] = []
        self.adj_list[u].append(v)
        self.adj_list[v].append(u)

    def depth_first_search(self, start):
        visited = set()
        result = []

        def dfs(v):
            visited.add(v)
            result.append(v)
            for neighbor in self.adj_list.get(v, []):
                if neighbor not in visited:
                    dfs(neighbor)

        dfs(start)
        return result

    def breadth_first_search(self, start):
        visited = set()
        queue = [start]
        visited.add(start)
        result = []

        while queue:
            v = queue.pop(0)
            result.append(v)
            for neighbor in self.adj_list.get(v, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

        return result

    def find_eulerian_cycle(self):
        # Проверка на наличие эйлерова цикла: все степени четные
        for node, neighbors in self.adj_list.items():
            if len(neighbors) % 2 != 0:
                return None

        stack = []
        cycle = []
        current_node = next(iter(self.adj_list))  # Начинаем с первой вершины

        # Копируем граф, чтобы не изменять оригинальный
        local_adj_list = {k: v[:] for k, v in self.adj_list.items()}

        while stack or current_node in local_adj_list:
            if local_adj_list[current_node]:
                stack.append(current_node)
                next_node = local_adj_list[current_node].pop()
                local_adj_list[next_node].remove(current_node)  # Удаляем обратное ребро
                current_node = next_node
            else:
                cycle.append(current_node)
                current_node = stack.pop() if stack else None

        return cycle[::-1]  # Возвращаем в обратном порядке для получения цикла

    def find_hamiltonian_cycle(self):
        path = []
        visited = set()

        def backtrack(current_node):
            if len(path) == len(self.adj_list) and path[0] in self.adj_list[current_node]:
                return path + [path[0]]  # Замыкаем цикл
            for neighbor in self.adj_list.get(current_node, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    path.append(neighbor)
                    result = backtrack(neighbor)
                    if result:
                        return result
                    path.pop()
                    visited.remove(neighbor)
            return None

        for start_node in self.adj_list:
            visited.add(start_node)
            path.append(start_node)
            cycle = backtrack(start_node)
            if cycle:
                return cycle
            path.pop()
            visited.clear()

        return None

    def dijkstra(self, start):
        import heapq
        
        distances = {node: float('inf') for node in self.adj_list}
        distances[start] = 0
        priority_queue = [(0, start)]

        while priority_queue:
            current_distance, current_node = heapq.heappop(priority_queue)

            if current_distance > distances[current_node]:
                continue

            for neighbor in self.adj_list.get(current_node, []):
                weight = 1  # Предполагаем, что вес всех рёбер равен 1
                distance = current_distance + weight

                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(priority_queue, (distance, neighbor))

        return distances

def run_tests():
    graph = Graph()

    # Тест 1: Добавление рёбер
    graph.add_edge(1, 2)
    graph.add_edge(2, 3)
    graph.add_edge(3, 1)
    graph.add_edge(1, 4)
    graph.add_edge(4, 2)

    print("Тест 1: Общий вид графа")
    print("Список смежности:", graph.adj_list)
    print()

    # Тест 2: Поиск в глубину
    dfs_result = graph.depth_first_search(1)
    print("Тест 2: Поиск в глубину от 1")
    print("Результат DFS:", dfs_result)
    print()

    # Тест 3: Поиск в ширину
    bfs_result = graph.breadth_first_search(1)
    print("Тест 3: Поиск в ширину от 1")
    print("Результат BFS:", bfs_result)
    print()

    # Тест 4: Нахождение эйлерова цикла
    graph.add_edge(3, 4)  # Теперь у нас есть возможность иметь эйлеров цикл
    eulerian_cycle = graph.find_eulerian_cycle()
    print("Тест 4: Нахождение эйлерова цикла")
    print("Результат эйлерова цикла:", eulerian_cycle)
    print()

    # Тест 5: Нахождение гамильтонова цикла
    hamiltonian_cycle = graph.find_hamiltonian_cycle()
    print("Тест 5: Нахождение гамильтонова цикла")
    print("Результат гамильтонова цикла:", hamiltonian_cycle)
    print()

    # Тест 6: Алгоритм Дейкстры
    graph2 = Graph()  # Создаём новый граф
    graph2.add_edge('A', 'B')
    graph2.add_edge('A', 'C')
    graph2.add_edge('B', 'D')
    graph2.add_edge('C', 'D')
    graph2.add_edge('C', 'E')
    graph2.add_edge('D', 'E')

    dijkstra_result = graph2.dijkstra('A')
    print("Тест 6: Алгоритм Дейкстры от 'A'")
    print("Посчитанные расстояния:", dijkstra_result)
    print()

run_tests()

```

    Тест 1: Общий вид графа
    Список смежности: {1: [2, 3, 4], 2: [1, 3, 4], 3: [2, 1], 4: [1, 2]}
    
    Тест 2: Поиск в глубину от 1
    Результат DFS: [1, 2, 3, 4]
    
    Тест 3: Поиск в ширину от 1
    Результат BFS: [1, 2, 3, 4]
    
    Тест 4: Нахождение эйлерова цикла
    Результат эйлерова цикла: None
    
    Тест 5: Нахождение гамильтонова цикла
    Результат гамильтонова цикла: [1, 2, 3, 4, 1]
    
    Тест 6: Алгоритм Дейкстры от 'A'
    Посчитанные расстояния: {'A': 0, 'B': 1, 'C': 1, 'D': 2, 'E': 2}
    


### Задание №**2.**
#### Реализовать приложение, для работы с графом, которое реализует следующий набор действий:

 а) инициализация графа;

 б) организация диалогового цикла с пользователем;



```python
class Graph:
    def __init__(self):
        self.adjacency_list = {}

    def add_vertex(self, vertex):
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = []
        else:
            print(f"Вершина '{vertex}' уже существует.")

    def add_edge(self, start_vertex, end_vertex):
        if start_vertex not in self.adjacency_list:
            print(f"Вершина '{start_vertex}' не найдена. Сначала добавьте её.")
            return
        if end_vertex not in self.adjacency_list:
            print(f"Вершина '{end_vertex}' не найдена. Сначала добавьте её.")
            return
        
        if end_vertex not in self.adjacency_list[start_vertex]:
            self.adjacency_list[start_vertex].append(end_vertex)
            self.adjacency_list[end_vertex].append(start_vertex)  # Для неориентированного графа
        else:
            print(f"Ребро между '{start_vertex}' и '{end_vertex}' уже существует.")

    def display(self):
        if not self.adjacency_list:
            print("Граф пуст.")
        else:
            for vertex, edges in self.adjacency_list.items():
                print(f"{vertex}: {', '.join(edges) if edges else 'нет рёбер'}")


def main():
    graph = Graph()
    
    while True:
        print("\nВыберите действие:")
        print("1. Добавить вершину")
        print("2. Добавить ребро")
        print("3. Показать граф")
        print("4. Выход")

        choice = input("Введите номер действия: ")

        match choice:
            case '1':
                vertex = input("Введите название вершины: ")
                graph.add_vertex(vertex)
            case '2':
                start_vertex = input("Введите стартовую вершину: ")
                end_vertex = input("Введите конечную вершину: ")
                graph.add_edge(start_vertex, end_vertex)
            case '3':
                print("Текущий граф:")
                graph.display()
            case '4':
                print("Выход из программы.")
                break
            case _:
                print("Неверный выбор, попробуйте снова.")


if __name__ == "__main__":
    main()

```

    
    Выберите действие:
    1. Добавить вершину
    2. Добавить ребро
    3. Показать граф
    4. Выход
    
    Выберите действие:
    1. Добавить вершину
    2. Добавить ребро
    3. Показать граф
    4. Выход
    
    Выберите действие:
    1. Добавить вершину
    2. Добавить ребро
    3. Показать граф
    4. Выход
    
    Выберите действие:
    1. Добавить вершину
    2. Добавить ребро
    3. Показать граф
    4. Выход
    
    Выберите действие:
    1. Добавить вершину
    2. Добавить ребро
    3. Показать граф
    4. Выход
    
    Выберите действие:
    1. Добавить вершину
    2. Добавить ребро
    3. Показать граф
    4. Выход
    Текущий граф:
    A: B
    B: A, C
    C: B
    
    Выберите действие:
    1. Добавить вершину
    2. Добавить ребро
    3. Показать граф
    4. Выход
    Выход из программы.


### Задание №**3.1.**
#### Найти кратчайший путь на графе между парами вершин ориентированного графа.

![variant_7](img/007.png)


```python
import heapq

def dijkstra_all_paths(graph, start, end):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    previous_vertices = {vertex: [] for vertex in graph}  # Список предшествующих вершин

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        if current_distance > distances[current_vertex]:
            continue

        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous_vertices[neighbor] = [current_vertex]
                heapq.heappush(priority_queue, (distance, neighbor))
            elif distance == distances[neighbor]:
                previous_vertices[neighbor].append(current_vertex)

    # Сбор всех путей
    def construct_paths(current_vertex):
        paths = []
        if previous_vertices[current_vertex] == []:
            return [[current_vertex]]
        for prev in previous_vertices[current_vertex]:
            for path in construct_paths(prev):
                paths.append(path + [current_vertex])
        return paths

    all_paths = construct_paths(end)
    return all_paths, distances[end]

# Определяем граф
graph = {
    1: {2: 1, 3: 2},
    2: {3: 3, 4: 14},
    3: {4: 6, 5: 9},
    4: {5: 4, 6: 10},
    5: {6: 7, 7: 12},
    6: {7: 2},
    7: {}
}

# Запуск алгоритма
paths, distance = dijkstra_all_paths(graph, 1, 6)
print(f"Кратчайшие пути от 1 до 6: {paths} с расстоянием {distance}")

```

    Кратчайшие пути от 1 до 6: [[1, 3, 4, 6], [1, 3, 5, 6]] с расстоянием 18


### Задание №**3.2.**
#### Реализовать алгоритм Дейкстры поиска кратчайшего пути на графе между парами вершин:

![variant_7.2](img/017.png)


```python
import heapq

def dijkstra_all_paths(graph, start, end):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    previous_vertices = {vertex: [] for vertex in graph}

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        if current_distance > distances[current_vertex]:
            continue

        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous_vertices[neighbor] = [current_vertex]
                heapq.heappush(priority_queue, (distance, neighbor))
            elif distance == distances[neighbor]:
                previous_vertices[neighbor].append(current_vertex)

    # Сбор всех путей
    def construct_paths(current_vertex):
        paths = []
        if previous_vertices[current_vertex] == []:
            return [[current_vertex]]
        for prev in previous_vertices[current_vertex]:
            for path in construct_paths(prev):
                paths.append(path + [current_vertex])
        return paths

    all_paths = construct_paths(end)
    return all_paths, distances[end]

# Определяем граф как неориентированный
graph = {
    1: {2: 4, 5: 9, 6: 10},
    2: {1: 4, 3: 1, 5: 3, 7: 2},
    3: {2: 1, 4: 1, 6: 1, 8: 7},
    4: {3: 1, 7: 8, 8: 6},
    5: {1: 9, 2: 3, 6: 4},
    6: {1: 10, 3: 1, 5: 4, 7: 1},
    7: {2: 2, 4: 8, 6: 1, 8: 5},
    8: {3: 7, 4: 6, 7: 5}
}

# Запуск алгоритма
paths, distance = dijkstra_all_paths(graph, 8, 2)
print(f"Кратчайшие пути от 8 до 2: {paths} с расстоянием {distance}")

```

    Кратчайшие пути от 8 до 2: [[8, 7, 2]] с расстоянием 7


### **Контрольные вопросы**

##### 1. Что такое граф? Что такое ребро и дуга графа?

**Граф** — это математическая структура, состоящая из множества вершин (или узлов) и набора рёбер (или дуг), соединяющих пары вершин. Граф может быть представлен как \( G = (V, E) \), где \( V \) — множество вершин, а \( E \) — множество рёбер.

- **Ребро** — это связь между двумя вершинами в неориентированном графе.
- **Дуга** — это связь между двумя вершинами в ориентированном графе, где важен порядок (направление) соединения.

##### 2. Что такое ориентированный граф и неориентированный граф?

- **Ориентированный граф** — граф, в котором рёбра имеют направление. Это означает, что каждое ребро ведёт от одной вершины к другой, и порядок важен. Например, если есть дуга от вершины A к вершине B, это не означает, что есть дуга от B к A.

- **Неориентированный граф** — граф, в котором рёбра не имеют направления. Ребро соединяет две вершины и не указывает, в каком направлении происходит соединение. Если есть ребро между A и B, это подразумевает наличие двусторонней связи.

##### 3. Какие вершины называют смежными? Какие ребра называют смежными? Что означает слово инцидентные?

- **Смежные вершины** — это вершины, соединенные общим ребром (или дугой). В неориентированном графе, если между двумя вершинами есть ребро, они считаются смежными.

- **Смежные рёбра** (или дуги) — это рёбра, которые имеют общую вершину.

- **Инцидентные** — слово используется для описания связи между вершиной и рёбером. Вершина инцидентна ребру, если это ребро соединяет данную вершину с другой.

##### 4. Что такое вес вершины, вес ребра?

- **Вес ребра** — это числовая величина, которая может представлять стоимость, длину или любую другую метрику, ассоциирующуюся с переходом или связью между двумя вершинами. Веса могут быть как положительными, так и отрицательными.

- **Вес вершины** — это аналогично весу ребра, но применяется к самой вершине. Вершины могут иметь ассоциированные значения, которые могут использоваться в различных алгоритмах, но не так широко, как веса рёбер.

##### 5. Какие способы представления графов существуют?

Существует несколько способов представления графов:

1. **Список смежности**: В каждой вершине хранится список соседних вершин. Это эффективный способ для разреженных графов.
   
2. **Матрица смежности**: Двумерный массив, где элемент [i][j] равен 1 (или весу ребра), если существует ребро между вершинами i и j, и 0 в противном случае. Этот вариант менее эффективен для разреженных графов.

3. **Список рёбер**: Список пар вершин, где каждая пара представляет собой ребро. Это также подходит для хранения графов, но менее компактно, чем список смежности.

##### 6. В чем разница между алгоритмами поиска в ширину и поиска в глубину?

- **Поиск в ширину (BFS)**:
  - Исследует вершины графа по уровням. Начинает с корневой (или стартовой) вершины и рассматривает все её соседние вершины, а затем переходит к соседям соседей, и так далее.
  - Использует очередь для хранения вершин для последующего обхода.
  - Хорош для нахождения кратчайшего пути в неориентированном графе.

- **Поиск в глубину (DFS)**:
  - Исследует граф, углубляясь в каждую ветвь до тех пор, пока не достигнет дна (или не встретит безвыходность), а затем возвращается и проверяет другие ветви.
  - Использует стек (или подразумевает рекурсию) для хранения вершин.
  - Может не находить кратчайший путь.

##### 7. Описать алгоритм нахождения кратчайшего пути.

Одним из популярных алгоритмов нахождения кратчайшего пути является алгоритм Дейкстры:

1. **Инициализация**: Установите дистанцию от начальной вершины до самой себя равной 0, а до всех остальных вершин — бесконечность. Поместите все вершины в очередь с приоритетом (или обычную очередь).

2. **Обработка**: Пока очередь не пуста:
   - Извлеките из очереди вершину с наименьшей дистанцией.
   - Для каждой смежной вершины:
     - Вычислите полную стоимость пути к смежной вершине (дистанция к текущей вершине + вес ребра).
     - Если новая полная стоимость меньше текущей известной стоимости, обновите её и обновите очередь.

3. **Завершение**: Программа завершает работу, когда все вершины обработаны, или позже, если минимальное расстояние до цели найдено.

##### 8. Описать алгоритмы нахождения эйлерова и гамильтонова цикла.

- **Эйлеров цикл**:
  - Это цикл, который проходит через каждое ребро графа ровно один раз и возвращается в начальную вершину. 
  - Для неориентированного графа эйлеров цикл существует, если все вершины имеют четный степень; для ориентированного графа — если все вершины имеют одинаковое количество входящих и исходящих рёбер.
  - Алгоритм: можно использовать метод Флёри, который подразумевает выбор рёбер поэтапно, следуя определённым правилам, и избегая создания изолированных рёбер.

- **Гамильтонов цикл**:
  - Это цикл, который проходит через каждую вершину графа ровно один раз и возвращается в начальную вершину.
  - Намного сложнее найти, поскольку это NP-полная задача. Не существует общего алгоритма, эффективного для всех типов графов.
  - Подходы включают поиск в глубину с возвратом (backtracking) и динамическое программирование, но они могут быть вычислительно затратными для больших графов.

