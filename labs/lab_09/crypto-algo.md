<!-- #region editable=true slideshow={"slide_type": ""} -->
## Лабораторная работа № 9 (Криптоалгоритмы)
***Выполнил***: Зейналли С.Р,  ***Группа***: ИУ10-36
<!-- #endregion -->

### **Цель работы**

Получение практических навыков защиты программного обеспечения от несанкционированного доступа путем шифрования с использованием криптоалгоритмов.

### **Симметричный Шифр** 

#### Шифр Вернама
Шифр Вернама, также известный как "один раз маска", представляет собой метод шифрования, где каждый символ открытого текста объединяется символом ключа с помощью операции XOR. Ключ должен быть как минимум такой же длины, как и текст, чтобы обеспечить безопасность. 



```python
import random
import base64

def generate_key(length):
    """Генерирует случайный ключ заданной длины."""
    return ''.join(random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') for _ in range(length))

def vernam_encrypt(plain_text, key):
    """Шифрует текст с использованием шифра Вернама."""
    return ''.join(chr(ord(p) ^ ord(k)) for p, k in zip(plain_text, key))

def vernam_decrypt(cipher_text, key):
    """Расшифровывает текст с использованием шифра Вернама."""
    return ''.join(chr(ord(c) ^ ord(k)) for c, k in zip(cipher_text, key))

def main():
    user_input = input("Введите текст для шифрования: ")
    key = generate_key(len(user_input))
    print(f"Сгенерированный ключ: {key}")
    
    encrypted_text = vernam_encrypt(user_input, key)
    # Кодируем зашифрованный текст в base64 для более легкого отображения
    encoded_encrypted_text = base64.b64encode(encrypted_text.encode()).decode()
    print(f"Зашифрованный текст (в формате base64): {encoded_encrypted_text}")
    
    # Декодируем текст перед расшифрованием
    decrypted_text = vernam_decrypt(base64.b64decode(encoded_encrypted_text).decode(), key)
    print(f"Расшифрованный текст: {decrypted_text}")

if __name__ == "__main__":
    main()

```

    Сгенерированный ключ: 2jXF9a
    Зашифрованный текст (в формате base64): 0I3QqtGg0bTQjNCj
    Расшифрованный текст: привет


### **Асимметричный шифр**
#### Криптосистема Рабина

Криптосистема Рабина — это асимметричная криптографическая система, основанная на сложности задачи факторизации больших чисел. Она была предложена Майклом Рабином в 1979 году. Основная идея заключается в шифровании с использованием квадратичных вычетов: шифртекст вычисляется как \( c \equiv m^2 \pmod{n} \), где \( n \) — произведение двух больших простых чисел.  

Ее основное преимущество в том, что она математически доказуемо так же сложна, как задача факторизации \( n \), но основной недостаток — возможность получения нескольких вариантов расшифрованного сообщения, что требует дополнительной обработки. 



```python
import random
import math

def is_prime(n):
    """Проверка числа на простоту"""
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

def generate_prime_number(key):
    """Генерация простого числа на основе пользовательского ключа"""
    # Используем ключ как seed для генератора случайных чисел
    random.seed(sum(ord(c) for c in str(key)))
    while True:
        # Генерируем число, которое при делении на 4 даёт остаток 3
        n = random.randint(100, 1000)
        if n % 4 == 3 and is_prime(n):
            return n

def mod_sqrt(a, p):
    """Нахождение квадратного корня по модулю p"""
    def legendre_symbol(a, p):
        return pow(a, (p - 1) // 2, p)

    if legendre_symbol(a, p) != 1:
        return None
    q = p - 1
    s = 0
    while q % 2 == 0:
        q //= 2
        s += 1
    if s == 1:
        return pow(a, (p + 1) // 4, p)
    z = 2
    while legendre_symbol(z, p) != -1:
        z += 1
    c = pow(z, q, p)
    r = pow(a, (q + 1) // 2, p)
    t = pow(a, q, p)
    m = s
    while t != 1:
        i = 0
        temp = t
        while temp != 1:
            temp = (temp * temp) % p
            i += 1
            if i == m:
                return None
        b = pow(c, 1 << (m - i - 1), p)
        r = (r * b) % p
        c = (b * b) % p
        t = (t * c) % p
        m = i
    return r

class RabinCryptosystem:
    def __init__(self, key):
        # Генерируем два простых числа p и q на основе пользовательского ключа
        random.seed(sum(ord(c) for c in str(key)))
        self.p = generate_prime_number(key + "p")
        self.q = generate_prime_number(key + "q")
        self.n = self.p * self.q

    def encrypt(self, message):
        """Шифрование сообщения"""
        # Преобразуем сообщение в числа и шифруем
        encrypted = []
        for char in message:
            m = ord(char)
            c = (m * m) % self.n
            encrypted.append(c)
        return encrypted

    def decrypt(self, encrypted_message):
        """Расшифрование сообщения"""
        decrypted = ""
        for c in encrypted_message:
            # Находим квадратные корни
            mp = mod_sqrt(c % self.p, self.p)
            mq = mod_sqrt(c % self.q, self.q)
            
            if mp is None or mq is None:
                continue

            # Используем китайскую теорему об остатках
            yp = self.q * pow(self.q, -1, self.p)
            yq = self.p * pow(self.p, -1, self.q)

            r1 = (mp * yp + mq * yq) % self.n
            r2 = (mp * yp - mq * yq) % self.n
            r3 = (-mp * yp + mq * yq) % self.n
            r4 = (-mp * yp - mq * yq) % self.n

            # Выбираем корректный результат (тот, который даст правильный символ ASCII)
            roots = [r1, r2, r3, r4]
            for root in roots:
                if 0 <= root < 256:  # Проверяем, что значение в диапазоне ASCII
                    decrypted += chr(root)
                    break

        return decrypted

# Пример использования
def main():
    # Пользовательский ключ
    key = "фф12К52"
    
    # Создаем экземпляр криптосистемы
    rabin = RabinCryptosystem(key)
    
    # Исходное сообщение
    message = input()
    print(f"Исходное сообщение: {message}")
    
    # Шифрование
    encrypted = rabin.encrypt(message)
    print(f"Зашифрованное сообщение: {encrypted}")
    
    # Расшифрование
    decrypted = rabin.decrypt(encrypted)
    print(f"Расшифрованное сообщение: {decrypted}")

if __name__ == "__main__":
    main()
```

    Исходное сообщение: hello
    Зашифрованное сообщение: [10816, 10201, 11664, 11664, 12321]
    Расшифрованное сообщение: hello


### **Контрольные вопросы**   

1. **Симметричные криптоалгоритмы** — это алгоритмы, в которых один и тот же ключ используется как для шифрования, так и для расшифрования данных.  
2. **Асимметричные криптоалгоритмы** — это алгоритмы, использующие два различных ключа: открытый (для шифрования) и закрытый (для расшифрования).  
3. **Классификация симметричных криптоалгоритмов**:  
   - Блочные шифры (например, AES, DES).  
   - Поточные шифры (например, RC4).  
4. **Классификация асимметричных криптоалгоритмов**:  
   - Алгоритмы на основе факторизации (например, RSA).  
   - Алгоритмы на основе дискретного логарифма (например, ElGamal).  
   - Алгоритмы на основе эллиптических кривых.  
5. **Обобщенная схема симметричной криптосистемы**:  
   - Данные \( P \) шифруются с использованием ключа \( K \), создавая шифртекст \( C \). Для расшифрования используется тот же ключ \( K \), чтобы получить исходные данные.  
6. **Блочные и поточные шифры**:  
   - Блочные шифры обрабатывают данные блоками фиксированного размера.  
   - Поточные шифры шифруют данные побитно или побайтово.  
7. **Методы подстановки**:  
   - Замена букв или символов (например, шифр Цезаря).  
   - Использование сложных таблиц подстановок (S-блоков).  
8. **Методы перестановки**:  
   - Перестановка символов по определенному правилу (например, шифр колонн).  
   - Множественные перестановки для увеличения сложности.  
9. **Шифрование методом гаммирования** — это наложение псевдослучайной последовательности (гаммы) на исходный текст с помощью операции XOR.  
10. **Ключ** — это секретный параметр, управляющий процессами шифрования и расшифрования.  
11. **Разовый блокнот** — метод шифрования, использующий случайный ключ длиной не меньше сообщения, который используется только один раз.  
12. **Криптостойкость системы** — это устойчивость криптосистемы к различным видам криптоанализа.  
13. **Правила использования ключа**:  
    - Секретность.  
    - Уникальность для каждого сеанса.  
    - Своевременная замена.  
